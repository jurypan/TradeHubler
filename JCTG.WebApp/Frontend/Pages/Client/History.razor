@page "/Clients/{clientid:long}/History";
@inject ClientRepository _clientRepository;
@inject DealRepository _dealRepository;
@inject OrderRepository _orderRepository
@using JCTG.WebApp.Frontend.Components.Tradingview

<h1>History</h1>

<Chart @ref=tv />

<br />
<br />

<h1>Numbers</h1>
<p>Total PNL: @_totalPnl</p>
<p>Total Commission: @_totalCommission</p>
<p>Total Swap Costs: @_totalSwapCosts</p>
<p>Total Spread costs: @_totalSpreadCosts</p>

<br />
<br />


<h1>Orders</h1>
<table cellpadding="1" cellspacing="0" width="100%" style="width:100%; border:1px solid black;">
    <tr>
        <th style="width:5%;">ID</th>
        <th style="width:5%;">Symbol</th>
        <th style="width:10%;">Type</th>
        <th style="width:20%;">Open Time</th>
        <th style="width:20%;">Close Time</th>
        <th style="width:10%;">PNL</th>
        <th style="width:10%;">Commission</th>
        <th style="width:10%;">Swap</th>
        <th style="width:10%;">Spreadcost</th>
    </tr>
    @foreach (var order in _orders.OrderByDescending(f => f.DateCreated))
    {
        <tr>
            <td>@order.ID</td>
            <td>@order.Symbol</td>
            <td>@order.Type</td>
            <td>@order.OpenTime</td>
            <td>@order.CloseTime</td>
            <td>@order.Pnl</td>
            <td>@order.Commission</td>
            <td>@order.Swap</td>
            <td>@order.SpreadCost.ToString("0.################")</td>
        </tr>
    }
</table>

@code {
    [Parameter]
    public long ClientId { get; set; }

    private Chart? tv;
    private IEnumerable<Entity.Deal>? deals;
    private List<Entity.Order> _orders = new();
    private Client? client;

    private double _totalPnl = 0.0;
    private double _totalCommission = 0.0;
    private double _totalSwapCosts = 0.0;
    private double _totalSpreadCosts = 0.0;

    protected async override Task OnInitializedAsync()
    {
        _orders = await _orderRepository.GetAll(692803787, ClientId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Only on first render
        if (!firstRender || tv == null)
            return;

        // Get data from database
        deals = await _dealRepository.GetAll(this.ClientId);
        client = await _clientRepository.GetById(692803787, this.ClientId);

        _totalPnl = Math.Round(deals.Select(f => f.Pnl).Sum(), 2);
        _totalCommission = Math.Round(deals.Select(f => f.Commission).Sum(), 2);
        _totalSwapCosts = Math.Round(deals.Select(f => f.Swap).Sum(), 2);
        _totalSpreadCosts = Math.Round(deals.Select(f => f.SpreadCost).Sum(), 2);

        // Init tradingview Chart
        await tv.InitAsync(new()
            {
                Width = -75,
                Height = 500,
            });

        // Do null reference check
        if(tv.IsInit)
        {
            // Calculate cumulative commission for each deal
            var cumulativeCommissions = new Dictionary<DateTime, decimal>();
            decimal totalCommission = 0.0M;
            foreach (var deal in deals.Where(f => f.AccountBalance.HasValue).OrderBy(f => f.DateCreated))
            {
                totalCommission += Convert.ToDecimal(deal.Commission);
                totalCommission += Convert.ToDecimal(deal.Swap);
                totalCommission += Convert.ToDecimal(deal.SpreadCost);
                cumulativeCommissions[deal.DateCreated] = totalCommission;
            }

            // Use the cumulative commissions in the query
            await tv.AddLineSeriesAsync(deals
                .Where(f => f.AccountBalance.HasValue && f.AccountBalance.Value > 0)
                .Select(x => new PricePoint()
                    {
                        Time = x.DateCreated,
                        Price = x.AccountBalance.HasValue ? Convert.ToDecimal(x.AccountBalance.Value) - cumulativeCommissions[x.DateCreated] : 0.0M
                    }).OrderBy(f => f.Time)
                        .ToList());


            // Load the chart
            await tv.AddAreaSeriesAsync(deals
                .Where(f => f.AccountBalance.HasValue && f.AccountBalance.Value > 0)
                .Select(x => new AreaPoint()
                {
                    Time = x.DateCreated,
                    Price = x.AccountBalance.HasValue ? Convert.ToDecimal(x.AccountBalance.Value) : 0.0M
                    }).OrderBy(f => f.Time)
                        .ToList());
        }
    }
}
